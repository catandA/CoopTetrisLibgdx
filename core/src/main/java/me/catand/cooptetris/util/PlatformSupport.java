package me.catand.cooptetris.util;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.Pixmap;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.PixmapPacker;
import com.badlogic.gdx.graphics.g2d.freetype.FreeTypeFontGenerator;

import java.util.HashMap;

public abstract class PlatformSupport {

    public abstract void updateDisplaySize();

    public boolean supportsFullScreen() {
        return true; //default
    }

    public static final int INSET_ALL = 3; //All insets, from hole punches to nav bars
    public static final int INSET_LRG = 2; //Only big insets, full size notches and nav bars
    public static final int INSET_BLK = 1; //only complete blocker assets like navbars

    public RectF getSafeInsets(int level) {
        return new RectF(
            Gdx.graphics.getSafeInsetLeft(),
            Gdx.graphics.getSafeInsetTop(),
            Gdx.graphics.getSafeInsetRight(),
            Gdx.graphics.getSafeInsetBottom()
        );
    }

    //returns a display cutout (if one is present) in device pixels, or empty if none is present
    public RectF getDisplayCutout() {
        return new RectF();
    }

    public abstract void updateSystemUI();

    public abstract boolean connectedToUnmeteredNetwork();

    public void setHonorSilentSwitch(boolean value) {
        //does nothing by default
    }

    public boolean openURI(String uri) {
        return Gdx.net.openURI(uri);
    }

    public void setOnscreenKeyboardVisible(boolean value, boolean multiline) {
        //by default ignore multiline
        Gdx.input.setOnscreenKeyboardVisible(value, Input.OnscreenKeyboardType.Default);
    }

    //TODO should consider spinning this into its own class, rather than platform support getting ever bigger
    protected static HashMap<FreeTypeFontGenerator, HashMap<Integer, BitmapFont>> fonts;

    protected int pageSize;
    protected PixmapPacker packer;

    public abstract void setupFontGenerators(int pageSize);

    protected abstract FreeTypeFontGenerator getGeneratorForString(String input);

    public abstract String[] splitforTextBlock(String text, boolean multiline);

    public void resetGenerators() {
        resetGenerators(true);
    }

    public void resetGenerators(boolean setupAfter) {
        if (fonts != null) {
            for (FreeTypeFontGenerator generator : fonts.keySet()) {
                for (BitmapFont f : fonts.get(generator).values()) {
                    f.dispose();
                }
                fonts.get(generator).clear();
                generator.dispose();
            }
            fonts.clear();
            if (packer != null) {
                for (PixmapPacker.Page p : packer.getPages()) {
                    p.getTexture().dispose();
                }
                packer.dispose();
            }
            fonts = null;
        }
        if (setupAfter) setupFontGenerators(pageSize);
    }

    public void reloadGenerators() {
        if (packer != null) {
            for (FreeTypeFontGenerator generator : fonts.keySet()) {
                for (BitmapFont f : fonts.get(generator).values()) {
                    f.dispose();
                }
                fonts.get(generator).clear();
            }
            if (packer != null) {
                for (PixmapPacker.Page p : packer.getPages()) {
                    p.getTexture().dispose();
                }
                packer.dispose();
            }
            packer = new PixmapPacker(pageSize, pageSize, Pixmap.Format.RGBA8888, 1, false);
        }
    }

    //flipped is needed because Shattered's graphics are y-down, while GDX graphics are y-up.
    //this is very confusing, I know.
    public BitmapFont getFont(int size, String text, boolean flipped, boolean border) {
        FreeTypeFontGenerator generator = getGeneratorForString(text);

        if (generator == null) {
            return null;
        }

        int key = size;
        if (border) key += Short.MAX_VALUE; //surely we'll never have a size above 32k
        if (flipped) key = -key;
        if (!fonts.get(generator).containsKey(key)) {
            FreeTypeFontGenerator.FreeTypeFontParameter parameters = new FreeTypeFontGenerator.FreeTypeFontParameter();
            parameters.size = size;
            parameters.flip = flipped;
            if (border) {
                parameters.borderWidth = parameters.size / 10f;
            }
            if (size >= 20) {
                parameters.renderCount = 2;
            } else {
                parameters.renderCount = 3;
            }
            parameters.hinting = FreeTypeFontGenerator.Hinting.None;
            parameters.spaceX = -(int) parameters.borderWidth;
            parameters.incremental = true;
            parameters.characters = "�";
            parameters.packer = packer;

            try {
                BitmapFont font = generator.generateFont(parameters);
                font.getData().missingGlyph = font.getData().getGlyph('�');
                fonts.get(generator).put(key, font);
            } catch (Exception e) {
                System.err.println(e.getMessage());
                return null;
            }
        }

        return fonts.get(generator).get(key);
    }

}
